import hashlib
import hmac
import json
import os
import subprocess
import sys
import time
import tempfile
import timesheetbot.settings as settings
import urllib.parse

from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse


def launch_independent_async_handling_process(data):
    """Saves data / spawn an analyzing process & return"""

    file_handler, file_path = tempfile.mkstemp(suffix=".json")
    os.write(file_handler, json.dumps(data).encode("utf-8"))
    os.close(file_handler)

    if settings.config["TIMESHEET_DEBUG_MODE"]:
        sys_descr_stdout, _ = tempfile.mkstemp(
            suffix=".debug", prefix="exec_log_stdout_" + ("%.2f" % (time.time()))
        )
        sys_descr_stderr, _ = tempfile.mkstemp(
            suffix=".debug", prefix="exec_log_stderr_" + ("%.2f" % (time.time()))
        )
        subprocess.Popen(
            [
                sys.executable,
                os.path.join(settings.BASE_DIR, "manage.py"),
                "analyze_slack_request",
                "--request_file",
                file_path,
            ],
            stdout=sys.stdout,
            stderr=sys.stdout
        )
    else:
        subprocess.Popen(
            [
                sys.executable,
                os.path.join(settings.BASE_DIR, "manage.py"),
                "analyze_slack_request",
                "--request_file",
                file_path,
            ],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )


@require_POST
@csrf_exempt
def handle_slack(request):
    """Receives posted data, handles encoding/dispatching"""

    decoded_body = request.body.decode("utf-8")
    if decoded_body.startswith("payload="):
        try:
            # Verify signature to prove that data is indeed generated by Slack
            request_timestamp = request.headers["X-Slack-Request-Timestamp"]
            if time.time() > float(
                settings.config["SLACK_QUERY_MAX_AGE_SECONDS"]
            ) + float(request_timestamp):
                raise ValueError("Query is too old hence suspect")
            data_signature = (
                "v0="
                + hmac.new(
                    settings.config["SLACK_SIGNING_SECRET"].encode("utf-8"),
                    ("v0:" + request_timestamp + ":").encode("utf-8") + request.body,
                    hashlib.sha256,
                ).hexdigest()
            )
            if not (data_signature == request.headers["X-Slack-Signature"]):
                raise ValueError("Query is not correctly signed")

            data_as_dict = json.loads(urllib.parse.unquote_plus(decoded_body[8:]))
            if "type" in data_as_dict:
                if (data_as_dict["type"] == "view_submission") or (
                    data_as_dict["type"] == "block_actions"
                ):
                    # Taken actions will (generally) be executed after the response
                    launch_independent_async_handling_process(data_as_dict)
                else:
                    raise ValueError("Unexpected data type")
        except (KeyError, ValueError, json.decoder.JSONDecodeError) as e:
            pass

    # Actually, to avoid difficulties, let's always content Slack and deal here with problems
    return JsonResponse({"response_action": "clear"}, status=200)
